# Лабораторная работа 2. IPC. Вариант 20

--- 
[Условие лабораторной](./lab2.md)

---

[Как собрать проект](#как-собрать-проект)

---

[Некоторые изменения по сравнению с условием](#как-собрать-проект)

---

[Архитектура](#архитектура)

---

## Как собрать проект

Запустите скрипт `build.sh`

```shell
chmod +x build.sh
./build.sh
```

Небольшие замечания по сборке:

- Необходимо иметь установленные в системе пакет `ncurses dev`. Скрипт автоматически пытается установить его для
  `Debian/Ubuntu/CentOS/Arch`, но на других дистрибутивах потребуется установить его самостоятельно
- Приложению для сборки нужен `protobuf`. В процессе сборки CMake сначала пытается найти установленный protobuf в
  системе и использовать его, если не
  получается - скачивает версию с GitHub. Учтите, что во втором случае вместе с проектом будет собираться protobuf из
  исходников

## Некоторые изменения по сравнению с условием

- Для соединения через `Message Queue` и `Fifo` использовалась архитектура как в сокетах
    - То есть, так как нет нормального способа определить, какое сообщение прочитано из очереди (свое или чужое) без
      дополнительной информации из самих данных, то будут создаваться два канала для каждого соединения вместо одного -
      на одно и на другое направление
- Немного оптимизирована работа с потоками: вместо того, чтобы выделять поток на каждого клиента и блокироваться на
  `read()`, сервер в неблокирующем режиме делает `read()` у всех клиентов в одном потоке, а уже при наличии сообщения
  обрабатывает его с помощью пула потоков
- Клиенты разделены по типу соединения, но хост умеет обрабатывать любой тип соединения

## Архитектура

Здесь краткое описание архитектуры, чтобы было проще осознавать

### Интерфейсы

* `Server`
    * Абстрактный интерфейс с `serve()`
    * Имплементации: `ChatHostServer`, `ChatClientServer`
* `Conn`
    * Единый интерфейс для IPC соединения: `read()`, `write()`, `connId()`
    * Реализации: `Conn_Fifo`, `Conn_Mq`, `Conn_Sock`
* `Console`
    * UI-абстракция с входом и каналами вывода (`info/system/private/broadcast`)
    * Реализация: `NcursesConsole`
* `TaskScheduler`
    * Интерфейс для создания пула задач и поддержки периодических задач
    * Реализация: `SimpleTaskScheduler`
* `SignalHandler`
    * Обработка сигналов в пользовательском коде
    * Реализации: `SingleSignalHandler`, `MultiSignalHandler`

### Хост 

* `ChatHostServer`
    * Основной сервер чата. Хранит клиентов, принимает handshake по `SIGUSR1`, ретранслирует сообщения

      Состав:

        * `MultiSignalHandler`. Слушает `SIGUSR1` от клиентов, инициирует подключение
        * `ChatClient`. Клиент чата для возможности общения

* `ClientConn`
    * Создает конкретный `Conn_*` по типу IPC и держит таймер неактивности.

Связи:

* `ChatHostServer` читает данные из `ClientConn::conn`, парсит protobuf и решает, куда их маршрутизировать
* Для общих сообщений выполняется обход всех `ClientConn`, для приватных - запись в нужный `Conn`
* Таймер неактивности (`Timer`) вызывает удаление клиента через callback

### Клиент 

* `ChatClientServer`
    * Клиентский процесс. На старте отправляет `SIGUSR1` хосту с типом IPC, ждёт `SIGUSR2` с назначенным id.

      Состав:

        * `SingleSignalHandler`. Получает `SIGUSR2` (подтверждение handshake).
        * `ChatClient`. Клиент чата для возможности общения. Парсит ввод пользователя (`/b`, `/w`, `/exit`) и печатает
          сообщения.
        * `Conn_*` создаётся после handshake.
        * `Timer` таймаут ожидания подтверждения.

Связи:

* `ChatClientServer` читает из `Conn`, парсит protobuf и передаёт в `ChatClient::onMessage()`.
* `ChatClient` отправляет сообщения через колбэки обратно в `ChatClientServer`, который сериализует и пишет в `Conn`.

### Общие утилиты и инфраструктура

* `MessageMaker`
    * Фабрика protobuf-сообщений (`chat::Message`) с timestamp.
* `Timer` и `TimerManager`
    * Таймер на callback с обновлением в общем менеджере. Менеджер в отдельном потоке перебирает все таймеры и обновляет
      у них прошедшее время
* `SimpleTaskScheduler`
    * Пул рабочих потоков для одноразовых задач и отдельные потоки для периодических.
    * То есть, сюда регистрируются все функции, которые должны работать в бесконечных циклах (и останавливаться с
      остановкой сервера), а также этот класс позволяет передавать таски вроде обработки пришедшего сообщения в
      отдельный поток
* `SignalUtils`
    * Установка обработчиков для `SIGUSR1/SIGUSR2` в handshake

### Потоки данных (вкратце)

1. Клиент запускается и отправляет `SIGUSR1` хосту с типом IPC
2. Хост принимает сигнал, создаёт `ClientConn`, шлёт `SIGUSR2` с id
3. Клиент создаёт свой `Conn_*` и переходит в активный режим
4. Сообщения сериализуются через protobuf, читаются через `Conn::read()`, печатаются через `ChatClient`

